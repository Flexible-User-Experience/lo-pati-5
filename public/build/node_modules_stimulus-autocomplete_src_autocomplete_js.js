"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_stimulus-autocomplete_src_autocomplete_js"],{

/***/ "./node_modules/stimulus-autocomplete/src/autocomplete.js":
/*!****************************************************************!*\
  !*** ./node_modules/stimulus-autocomplete/src/autocomplete.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Autocomplete),
/* harmony export */   "Autocomplete": () => (/* binding */ Autocomplete)
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


const optionSelector = "[role='option']:not([aria-disabled])"
const activeSelector = "[aria-selected='true']"

class Autocomplete extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["input", "hidden", "results"]
  static classes = ["selected"]
  static values = {
    ready: Boolean,
    submitOnEnter: Boolean,
    url: String,
    minLength: Number,
    delay: { type: Number, default: 300 },
  }

  connect() {
    this.close()

    if(!this.inputTarget.hasAttribute("autocomplete")) this.inputTarget.setAttribute("autocomplete", "off")
    this.inputTarget.setAttribute("spellcheck", "false")

    this.mouseDown = false

    this.onInputChange = debounce(this.onInputChange, this.delayValue)

    this.inputTarget.addEventListener("keydown", this.onKeydown)
    this.inputTarget.addEventListener("blur", this.onInputBlur)
    this.inputTarget.addEventListener("input", this.onInputChange)
    this.resultsTarget.addEventListener("mousedown", this.onResultsMouseDown)
    this.resultsTarget.addEventListener("click", this.onResultsClick)

    if (this.inputTarget.hasAttribute("autofocus")) {
      this.inputTarget.focus()
    }

    this.readyValue = true
  }

  disconnect() {
    if (this.hasInputTarget) {
      this.inputTarget.removeEventListener("keydown", this.onKeydown)
      this.inputTarget.removeEventListener("blur", this.onInputBlur)
      this.inputTarget.removeEventListener("input", this.onInputChange)
    }

    if (this.hasResultsTarget) {
      this.resultsTarget.removeEventListener("mousedown", this.onResultsMouseDown)
      this.resultsTarget.removeEventListener("click", this.onResultsClick)
    }
  }

  sibling(next) {
    const options = this.options
    const selected = this.selectedOption
    const index = options.indexOf(selected)
    const sibling = next ? options[index + 1] : options[index - 1]
    const def = next ? options[0] : options[options.length - 1]
    return sibling || def
  }

  select(target) {
    const previouslySelected = this.selectedOption
    if (previouslySelected) {
      previouslySelected.removeAttribute("aria-selected")
      previouslySelected.classList.remove(...this.selectedClassesOrDefault)
    }

    target.setAttribute("aria-selected", "true")
    target.classList.add(...this.selectedClassesOrDefault)
    this.inputTarget.setAttribute("aria-activedescendant", target.id)
    target.scrollIntoView({ behavior: "smooth", block: "nearest" })
  }

  onKeydown = (event) => {
    const handler = this[`on${event.key}Keydown`]
    if (handler) handler(event)
  }

  onEscapeKeydown = (event) => {
    if (!this.resultsShown) return

    this.hideAndRemoveOptions()
    event.stopPropagation()
    event.preventDefault()
  }

  onArrowDownKeydown = (event) => {
    const item = this.sibling(true)
    if (item) this.select(item)
    event.preventDefault()
  }

  onArrowUpKeydown = (event) => {
    const item = this.sibling(false)
    if (item) this.select(item)
    event.preventDefault()
  }

  onTabKeydown = (event) => {
    const selected = this.selectedOption
    if (selected) this.commit(selected)
  }

  onEnterKeydown = (event) => {
    const selected = this.selectedOption
    if (selected && this.resultsShown) {
      this.commit(selected)
      if (!this.hasSubmitOnEnterValue) {
        event.preventDefault()
      }
    }
  }

  onInputBlur = () => {
    if (this.mouseDown) return
    this.close()
  }

  commit(selected) {
    if (selected.getAttribute("aria-disabled") === "true") return

    if (selected instanceof HTMLAnchorElement) {
      selected.click()
      this.close()
      return
    }

    const textValue = selected.getAttribute("data-autocomplete-label") || selected.textContent.trim()
    const value = selected.getAttribute("data-autocomplete-value") || textValue
    this.inputTarget.value = textValue

    if (this.hasHiddenTarget) {
      this.hiddenTarget.value = value
      this.hiddenTarget.dispatchEvent(new Event("input"))
      this.hiddenTarget.dispatchEvent(new Event("change"))
    } else {
      this.inputTarget.value = value
    }

    this.inputTarget.focus()
    this.hideAndRemoveOptions()

    this.element.dispatchEvent(
      new CustomEvent("autocomplete.change", {
        bubbles: true,
        detail: { value: value, textValue: textValue, selected: selected }
      })
    )
  }

  clear() {
    this.inputTarget.value = ""
    if (this.hasHiddenTarget) this.hiddenTarget.value = ""
  }

  onResultsClick = (event) => {
    if (!(event.target instanceof Element)) return
    const selected = event.target.closest(optionSelector)
    if (selected) this.commit(selected)
  }

  onResultsMouseDown = () => {
    this.mouseDown = true
    this.resultsTarget.addEventListener("mouseup", () => {
      this.mouseDown = false
    }, { once: true })
  }

  onInputChange = () => {
    this.element.removeAttribute("value")
    if (this.hasHiddenTarget) this.hiddenTarget.value = ""

    const query = this.inputTarget.value.trim()
    if (query && query.length >= this.minLengthValue) {
      this.fetchResults(query)
    } else {
      this.hideAndRemoveOptions()
    }
  }

  identifyOptions() {
    let id = 0
    const optionsWithoutId = this.resultsTarget.querySelectorAll(`${optionSelector}:not([id])`)
    optionsWithoutId.forEach((el) => {
      el.id = `${this.resultsTarget.id}-option-${id++}`
    })
  }

  hideAndRemoveOptions() {
    this.close()
    this.resultsTarget.innerHTML = null
  }

  fetchResults = async (query) => {
    if (!this.hasUrlValue) return

    const url = this.buildURL(query)
    try {
      this.element.dispatchEvent(new CustomEvent("loadstart"))
      const html = await this.doFetch(url)
      this.replaceResults(html)
      this.element.dispatchEvent(new CustomEvent("load"))
      this.element.dispatchEvent(new CustomEvent("loadend"))
    } catch(error) {
      this.element.dispatchEvent(new CustomEvent("error"))
      this.element.dispatchEvent(new CustomEvent("loadend"))
      throw error
    }
  }

  buildURL(query) {
    const url = new URL(this.urlValue, window.location.href)
    const params = new URLSearchParams(url.search.slice(1))
    params.append("q", query)
    url.search = params.toString()

    return url.toString()
  }

  doFetch = async (url) => {
    const response = await fetch(url, this.optionsForFetch())
    const html = await response.text()
    return html
  }

  replaceResults(html) {
    this.resultsTarget.innerHTML = html
    this.identifyOptions()
    if (!!this.options) {
      this.open()
    } else {
      this.close()
    }
  }

  open() {
    if (this.resultsShown) return

    this.resultsShown = true
    this.element.setAttribute("aria-expanded", "true")
    this.element.dispatchEvent(
      new CustomEvent("toggle", {
        detail: { action: "open", inputTarget: this.inputTarget, resultsTarget: this.resultsTarget }
      })
    )
  }

  close() {
    if (!this.resultsShown) return

    this.resultsShown = false
    this.inputTarget.removeAttribute("aria-activedescendant")
    this.element.setAttribute("aria-expanded", "false")
    this.element.dispatchEvent(
      new CustomEvent("toggle", {
        detail: { action: "close", inputTarget: this.inputTarget, resultsTarget: this.resultsTarget }
      })
    )
  }

  get resultsShown() {
    return !this.resultsTarget.hidden
  }

  set resultsShown(value) {
    this.resultsTarget.hidden = !value
  }

  get options() {
    return Array.from(this.resultsTarget.querySelectorAll(optionSelector))
  }

  get selectedOption() {
    return this.resultsTarget.querySelector(activeSelector)
  }

  get selectedClassesOrDefault() {
    return this.hasSelectedClass ? this.selectedClasses : ["active"]
  }

  optionsForFetch() {
    return { headers: { "X-Requested-With": "XMLHttpRequest" } } // override if you need
  }
}

const debounce = (fn, delay = 10) => {
  let timeoutId = null

  return (...args) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(fn, delay)
  }
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX3N0aW11bHVzLWF1dG9jb21wbGV0ZV9zcmNfYXV0b2NvbXBsZXRlX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUErQzs7QUFFL0M7QUFDQTs7QUFFZSwyQkFBMkIsMERBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRCQUE0QjtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0NBQXNDO0FBQ2xFOztBQUVBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUksWUFBWTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FLGVBQWU7QUFDbkY7QUFDQSxpQkFBaUIsc0JBQXNCLFVBQVUsS0FBSztBQUN0RCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFdBQVcseUNBQXlDO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdGltdWx1cy1hdXRvY29tcGxldGUvc3JjL2F1dG9jb21wbGV0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSBcIkBob3R3aXJlZC9zdGltdWx1c1wiXG5cbmNvbnN0IG9wdGlvblNlbGVjdG9yID0gXCJbcm9sZT0nb3B0aW9uJ106bm90KFthcmlhLWRpc2FibGVkXSlcIlxuY29uc3QgYWN0aXZlU2VsZWN0b3IgPSBcIlthcmlhLXNlbGVjdGVkPSd0cnVlJ11cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvY29tcGxldGUgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgc3RhdGljIHRhcmdldHMgPSBbXCJpbnB1dFwiLCBcImhpZGRlblwiLCBcInJlc3VsdHNcIl1cbiAgc3RhdGljIGNsYXNzZXMgPSBbXCJzZWxlY3RlZFwiXVxuICBzdGF0aWMgdmFsdWVzID0ge1xuICAgIHJlYWR5OiBCb29sZWFuLFxuICAgIHN1Ym1pdE9uRW50ZXI6IEJvb2xlYW4sXG4gICAgdXJsOiBTdHJpbmcsXG4gICAgbWluTGVuZ3RoOiBOdW1iZXIsXG4gICAgZGVsYXk6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAzMDAgfSxcbiAgfVxuXG4gIGNvbm5lY3QoKSB7XG4gICAgdGhpcy5jbG9zZSgpXG5cbiAgICBpZighdGhpcy5pbnB1dFRhcmdldC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIikpIHRoaXMuaW5wdXRUYXJnZXQuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlXCIsIFwib2ZmXCIpXG4gICAgdGhpcy5pbnB1dFRhcmdldC5zZXRBdHRyaWJ1dGUoXCJzcGVsbGNoZWNrXCIsIFwiZmFsc2VcIilcblxuICAgIHRoaXMubW91c2VEb3duID0gZmFsc2VcblxuICAgIHRoaXMub25JbnB1dENoYW5nZSA9IGRlYm91bmNlKHRoaXMub25JbnB1dENoYW5nZSwgdGhpcy5kZWxheVZhbHVlKVxuXG4gICAgdGhpcy5pbnB1dFRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5ZG93bilcbiAgICB0aGlzLmlucHV0VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMub25JbnB1dEJsdXIpXG4gICAgdGhpcy5pbnB1dFRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5vbklucHV0Q2hhbmdlKVxuICAgIHRoaXMucmVzdWx0c1RhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25SZXN1bHRzTW91c2VEb3duKVxuICAgIHRoaXMucmVzdWx0c1RhcmdldC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5vblJlc3VsdHNDbGljaylcblxuICAgIGlmICh0aGlzLmlucHV0VGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSkge1xuICAgICAgdGhpcy5pbnB1dFRhcmdldC5mb2N1cygpXG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeVZhbHVlID0gdHJ1ZVxuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5oYXNJbnB1dFRhcmdldCkge1xuICAgICAgdGhpcy5pbnB1dFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5ZG93bilcbiAgICAgIHRoaXMuaW5wdXRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5vbklucHV0Qmx1cilcbiAgICAgIHRoaXMuaW5wdXRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMub25JbnB1dENoYW5nZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNSZXN1bHRzVGFyZ2V0KSB7XG4gICAgICB0aGlzLnJlc3VsdHNUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uUmVzdWx0c01vdXNlRG93bilcbiAgICAgIHRoaXMucmVzdWx0c1RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5vblJlc3VsdHNDbGljaylcbiAgICB9XG4gIH1cblxuICBzaWJsaW5nKG5leHQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkT3B0aW9uXG4gICAgY29uc3QgaW5kZXggPSBvcHRpb25zLmluZGV4T2Yoc2VsZWN0ZWQpXG4gICAgY29uc3Qgc2libGluZyA9IG5leHQgPyBvcHRpb25zW2luZGV4ICsgMV0gOiBvcHRpb25zW2luZGV4IC0gMV1cbiAgICBjb25zdCBkZWYgPSBuZXh0ID8gb3B0aW9uc1swXSA6IG9wdGlvbnNbb3B0aW9ucy5sZW5ndGggLSAxXVxuICAgIHJldHVybiBzaWJsaW5nIHx8IGRlZlxuICB9XG5cbiAgc2VsZWN0KHRhcmdldCkge1xuICAgIGNvbnN0IHByZXZpb3VzbHlTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRPcHRpb25cbiAgICBpZiAocHJldmlvdXNseVNlbGVjdGVkKSB7XG4gICAgICBwcmV2aW91c2x5U2VsZWN0ZWQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKVxuICAgICAgcHJldmlvdXNseVNlbGVjdGVkLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5zZWxlY3RlZENsYXNzZXNPckRlZmF1bHQpXG4gICAgfVxuXG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpXG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5zZWxlY3RlZENsYXNzZXNPckRlZmF1bHQpXG4gICAgdGhpcy5pbnB1dFRhcmdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgdGFyZ2V0LmlkKVxuICAgIHRhcmdldC5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiBcInNtb290aFwiLCBibG9jazogXCJuZWFyZXN0XCIgfSlcbiAgfVxuXG4gIG9uS2V5ZG93biA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzW2BvbiR7ZXZlbnQua2V5fUtleWRvd25gXVxuICAgIGlmIChoYW5kbGVyKSBoYW5kbGVyKGV2ZW50KVxuICB9XG5cbiAgb25Fc2NhcGVLZXlkb3duID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aGlzLnJlc3VsdHNTaG93bikgcmV0dXJuXG5cbiAgICB0aGlzLmhpZGVBbmRSZW1vdmVPcHRpb25zKClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxuXG4gIG9uQXJyb3dEb3duS2V5ZG93biA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnNpYmxpbmcodHJ1ZSlcbiAgICBpZiAoaXRlbSkgdGhpcy5zZWxlY3QoaXRlbSlcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBvbkFycm93VXBLZXlkb3duID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuc2libGluZyhmYWxzZSlcbiAgICBpZiAoaXRlbSkgdGhpcy5zZWxlY3QoaXRlbSlcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBvblRhYktleWRvd24gPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRPcHRpb25cbiAgICBpZiAoc2VsZWN0ZWQpIHRoaXMuY29tbWl0KHNlbGVjdGVkKVxuICB9XG5cbiAgb25FbnRlcktleWRvd24gPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRPcHRpb25cbiAgICBpZiAoc2VsZWN0ZWQgJiYgdGhpcy5yZXN1bHRzU2hvd24pIHtcbiAgICAgIHRoaXMuY29tbWl0KHNlbGVjdGVkKVxuICAgICAgaWYgKCF0aGlzLmhhc1N1Ym1pdE9uRW50ZXJWYWx1ZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25JbnB1dEJsdXIgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMubW91c2VEb3duKSByZXR1cm5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIGNvbW1pdChzZWxlY3RlZCkge1xuICAgIGlmIChzZWxlY3RlZC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIpID09PSBcInRydWVcIikgcmV0dXJuXG5cbiAgICBpZiAoc2VsZWN0ZWQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCkge1xuICAgICAgc2VsZWN0ZWQuY2xpY2soKVxuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0VmFsdWUgPSBzZWxlY3RlZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWF1dG9jb21wbGV0ZS1sYWJlbFwiKSB8fCBzZWxlY3RlZC50ZXh0Q29udGVudC50cmltKClcbiAgICBjb25zdCB2YWx1ZSA9IHNlbGVjdGVkLmdldEF0dHJpYnV0ZShcImRhdGEtYXV0b2NvbXBsZXRlLXZhbHVlXCIpIHx8IHRleHRWYWx1ZVxuICAgIHRoaXMuaW5wdXRUYXJnZXQudmFsdWUgPSB0ZXh0VmFsdWVcblxuICAgIGlmICh0aGlzLmhhc0hpZGRlblRhcmdldCkge1xuICAgICAgdGhpcy5oaWRkZW5UYXJnZXQudmFsdWUgPSB2YWx1ZVxuICAgICAgdGhpcy5oaWRkZW5UYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiKSlcbiAgICAgIHRoaXMuaGlkZGVuVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiY2hhbmdlXCIpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlucHV0VGFyZ2V0LnZhbHVlID0gdmFsdWVcbiAgICB9XG5cbiAgICB0aGlzLmlucHV0VGFyZ2V0LmZvY3VzKClcbiAgICB0aGlzLmhpZGVBbmRSZW1vdmVPcHRpb25zKClcblxuICAgIHRoaXMuZWxlbWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IEN1c3RvbUV2ZW50KFwiYXV0b2NvbXBsZXRlLmNoYW5nZVwiLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGRldGFpbDogeyB2YWx1ZTogdmFsdWUsIHRleHRWYWx1ZTogdGV4dFZhbHVlLCBzZWxlY3RlZDogc2VsZWN0ZWQgfVxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLmlucHV0VGFyZ2V0LnZhbHVlID0gXCJcIlxuICAgIGlmICh0aGlzLmhhc0hpZGRlblRhcmdldCkgdGhpcy5oaWRkZW5UYXJnZXQudmFsdWUgPSBcIlwiXG4gIH1cblxuICBvblJlc3VsdHNDbGljayA9IChldmVudCkgPT4ge1xuICAgIGlmICghKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpKSByZXR1cm5cbiAgICBjb25zdCBzZWxlY3RlZCA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KG9wdGlvblNlbGVjdG9yKVxuICAgIGlmIChzZWxlY3RlZCkgdGhpcy5jb21taXQoc2VsZWN0ZWQpXG4gIH1cblxuICBvblJlc3VsdHNNb3VzZURvd24gPSAoKSA9PiB7XG4gICAgdGhpcy5tb3VzZURvd24gPSB0cnVlXG4gICAgdGhpcy5yZXN1bHRzVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgIHRoaXMubW91c2VEb3duID0gZmFsc2VcbiAgICB9LCB7IG9uY2U6IHRydWUgfSlcbiAgfVxuXG4gIG9uSW5wdXRDaGFuZ2UgPSAoKSA9PiB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpXG4gICAgaWYgKHRoaXMuaGFzSGlkZGVuVGFyZ2V0KSB0aGlzLmhpZGRlblRhcmdldC52YWx1ZSA9IFwiXCJcblxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5pbnB1dFRhcmdldC52YWx1ZS50cmltKClcbiAgICBpZiAocXVlcnkgJiYgcXVlcnkubGVuZ3RoID49IHRoaXMubWluTGVuZ3RoVmFsdWUpIHtcbiAgICAgIHRoaXMuZmV0Y2hSZXN1bHRzKHF1ZXJ5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGVBbmRSZW1vdmVPcHRpb25zKClcbiAgICB9XG4gIH1cblxuICBpZGVudGlmeU9wdGlvbnMoKSB7XG4gICAgbGV0IGlkID0gMFxuICAgIGNvbnN0IG9wdGlvbnNXaXRob3V0SWQgPSB0aGlzLnJlc3VsdHNUYXJnZXQucXVlcnlTZWxlY3RvckFsbChgJHtvcHRpb25TZWxlY3Rvcn06bm90KFtpZF0pYClcbiAgICBvcHRpb25zV2l0aG91dElkLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBlbC5pZCA9IGAke3RoaXMucmVzdWx0c1RhcmdldC5pZH0tb3B0aW9uLSR7aWQrK31gXG4gICAgfSlcbiAgfVxuXG4gIGhpZGVBbmRSZW1vdmVPcHRpb25zKCkge1xuICAgIHRoaXMuY2xvc2UoKVxuICAgIHRoaXMucmVzdWx0c1RhcmdldC5pbm5lckhUTUwgPSBudWxsXG4gIH1cblxuICBmZXRjaFJlc3VsdHMgPSBhc3luYyAocXVlcnkpID0+IHtcbiAgICBpZiAoIXRoaXMuaGFzVXJsVmFsdWUpIHJldHVyblxuXG4gICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVSTChxdWVyeSlcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwibG9hZHN0YXJ0XCIpKVxuICAgICAgY29uc3QgaHRtbCA9IGF3YWl0IHRoaXMuZG9GZXRjaCh1cmwpXG4gICAgICB0aGlzLnJlcGxhY2VSZXN1bHRzKGh0bWwpXG4gICAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJsb2FkXCIpKVxuICAgICAgdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwibG9hZGVuZFwiKSlcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJlcnJvclwiKSlcbiAgICAgIHRoaXMuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImxvYWRlbmRcIikpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGJ1aWxkVVJMKHF1ZXJ5KSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybFZhbHVlLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5zZWFyY2guc2xpY2UoMSkpXG4gICAgcGFyYW1zLmFwcGVuZChcInFcIiwgcXVlcnkpXG4gICAgdXJsLnNlYXJjaCA9IHBhcmFtcy50b1N0cmluZygpXG5cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKClcbiAgfVxuXG4gIGRvRmV0Y2ggPSBhc3luYyAodXJsKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHRoaXMub3B0aW9uc0ZvckZldGNoKCkpXG4gICAgY29uc3QgaHRtbCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgIHJldHVybiBodG1sXG4gIH1cblxuICByZXBsYWNlUmVzdWx0cyhodG1sKSB7XG4gICAgdGhpcy5yZXN1bHRzVGFyZ2V0LmlubmVySFRNTCA9IGh0bWxcbiAgICB0aGlzLmlkZW50aWZ5T3B0aW9ucygpXG4gICAgaWYgKCEhdGhpcy5vcHRpb25zKSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBvcGVuKCkge1xuICAgIGlmICh0aGlzLnJlc3VsdHNTaG93bikgcmV0dXJuXG5cbiAgICB0aGlzLnJlc3VsdHNTaG93biA9IHRydWVcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIilcbiAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudChcInRvZ2dsZVwiLCB7XG4gICAgICAgIGRldGFpbDogeyBhY3Rpb246IFwib3BlblwiLCBpbnB1dFRhcmdldDogdGhpcy5pbnB1dFRhcmdldCwgcmVzdWx0c1RhcmdldDogdGhpcy5yZXN1bHRzVGFyZ2V0IH1cbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLnJlc3VsdHNTaG93bikgcmV0dXJuXG5cbiAgICB0aGlzLnJlc3VsdHNTaG93biA9IGZhbHNlXG4gICAgdGhpcy5pbnB1dFRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIilcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpXG4gICAgdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ3VzdG9tRXZlbnQoXCJ0b2dnbGVcIiwge1xuICAgICAgICBkZXRhaWw6IHsgYWN0aW9uOiBcImNsb3NlXCIsIGlucHV0VGFyZ2V0OiB0aGlzLmlucHV0VGFyZ2V0LCByZXN1bHRzVGFyZ2V0OiB0aGlzLnJlc3VsdHNUYXJnZXQgfVxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICBnZXQgcmVzdWx0c1Nob3duKCkge1xuICAgIHJldHVybiAhdGhpcy5yZXN1bHRzVGFyZ2V0LmhpZGRlblxuICB9XG5cbiAgc2V0IHJlc3VsdHNTaG93bih2YWx1ZSkge1xuICAgIHRoaXMucmVzdWx0c1RhcmdldC5oaWRkZW4gPSAhdmFsdWVcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVzdWx0c1RhcmdldC5xdWVyeVNlbGVjdG9yQWxsKG9wdGlvblNlbGVjdG9yKSlcbiAgfVxuXG4gIGdldCBzZWxlY3RlZE9wdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHRzVGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoYWN0aXZlU2VsZWN0b3IpXG4gIH1cblxuICBnZXQgc2VsZWN0ZWRDbGFzc2VzT3JEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLmhhc1NlbGVjdGVkQ2xhc3MgPyB0aGlzLnNlbGVjdGVkQ2xhc3NlcyA6IFtcImFjdGl2ZVwiXVxuICB9XG5cbiAgb3B0aW9uc0ZvckZldGNoKCkge1xuICAgIHJldHVybiB7IGhlYWRlcnM6IHsgXCJYLVJlcXVlc3RlZC1XaXRoXCI6IFwiWE1MSHR0cFJlcXVlc3RcIiB9IH0gLy8gb3ZlcnJpZGUgaWYgeW91IG5lZWRcbiAgfVxufVxuXG5jb25zdCBkZWJvdW5jZSA9IChmbiwgZGVsYXkgPSAxMCkgPT4ge1xuICBsZXQgdGltZW91dElkID0gbnVsbFxuXG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgdGltZW91dElkID0gc2V0VGltZW91dChmbiwgZGVsYXkpXG4gIH1cbn1cblxuZXhwb3J0IHsgQXV0b2NvbXBsZXRlIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==